#!/usr/bin/env python3

import subprocess
import time
import sys
import re
from typing import List, Tuple, IO

# This script acts as a wrapper to run any command while simultaneously
# monitoring system resources (CPU, memory, swap). It generates a summary
# report after the command finishes.

# --- Configuration ---
REPORT_FILE = "resource_report.txt"
TEMP_CPU_LOG = "cpu_temp.log"
TEMP_VMSTAT_LOG = "vmstat_temp.log"
DEFAULT_TEST_DURATION = 10 # Default duration in seconds if not specified in the command

def get_total_memory() -> str:
    """
    Retrieves the total system memory in MB using the 'free' command.
    """
    try:
        output = subprocess.check_output(['free', '-m'], text=True)
        lines = output.strip().split('\n')
        total_mem = lines[1].split()[1]
        return f"{total_mem} MB"
    except (subprocess.CalledProcessError, IndexError, FileNotFoundError):
        return "N/A"

def extract_duration_from_command(command: List[str]) -> int:
    """
    Parses the command for duration flags like -t, -d, or --time.
    """
    duration = DEFAULT_TEST_DURATION
    try:
        # Check for iperf-style duration flags
        if '-t' in command:
            duration = int(command[command.index('-t') + 1])
        # Check for wrk-style duration flags
        elif '-d' in command:
            duration_str = command[command.index('-d') + 1]
            if duration_str.endswith('s'):
                duration = int(duration_str[:-1])
        # Check for --time
        elif '--time' in command:
            duration = int(command[command.index('--time') + 1])
    except (ValueError, IndexError):
        print(f"Warning: Could not parse test duration from command. Using default of {DEFAULT_TEST_DURATION} seconds.", file=sys.stderr)
        return DEFAULT_TEST_DURATION
    
    return duration

def run_monitoring_commands(duration: int) -> Tuple[str, str]:
    """
    Runs mpstat and vmstat as separate, single-shot commands for the given duration.
    Returns their complete output.
    """
    print("Running monitoring tools for the duration of the command...")
    
    try:
        # mpstat: Monitors CPU usage (all cores) every 1 second, for the duration
        mpstat_proc = subprocess.Popen(
            ['mpstat', '-P', 'ALL', '1', str(duration)],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True
        )
        
        # vmstat: Reports virtual memory and system stats every 1 second, in MB, for the duration
        vmstat_proc = subprocess.Popen(
            ['vmstat', '-n', '1', '-S', 'M', str(duration)],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True
        )
        
        mpstat_output, _ = mpstat_proc.communicate()
        vmstat_output, _ = vmstat_proc.communicate()
        
        return mpstat_output, vmstat_output
        
    except FileNotFoundError as e:
        print(f"Error: Command not found - {e}. Please ensure `sysstat` and `procps` are installed.")
        sys.exit(1)

def generate_report(command: List[str], mpstat_output: str, vmstat_output: str, total_memory: str) -> None:
    """
    Parses the raw output and generates a summary report file.
    """
    print("Generating final report...")
    
    # --- Parse mpstat output ---
    avg_cpu = "N/A"
    mpstat_lines = mpstat_output.strip().split('\n')
    
    for line in mpstat_lines:
        if line.startswith("Average:") and "all" in line:
            fields = line.split()
            if len(fields) > 1 and fields[-1].replace('.', '', 1).isdigit():
                idle_percent = float(fields[-1])
                avg_cpu = f"{100 - idle_percent:.2f}"
            break

    # --- Parse vmstat output ---
    avg_swpd, avg_free, avg_si, avg_so = "0.00", "0.00", "0.00", "0.00"
    vmstat_lines = vmstat_output.strip().split('\n')
    
    if len(vmstat_lines) > 2:
        headers = vmstat_lines[1].split()
        col_indices = {header: headers.index(header) for header in headers if header}
        data_lines = vmstat_lines[2:]
        
        if data_lines:
            swpd_sum, free_sum, si_sum, so_sum, count = 0, 0, 0, 0, 0
            for line in data_lines:
                fields = line.split()
                if len(fields) >= len(headers):
                    try:
                        swpd_sum += int(fields[col_indices['swpd']])
                        free_sum += int(fields[col_indices['free']])
                        si_sum += int(fields[col_indices['si']])
                        so_sum += int(fields[col_indices['so']])
                        count += 1
                    except (ValueError, IndexError):
                        continue
            
            if count > 0:
                avg_swpd = f"{swpd_sum / count:.2f}"
                avg_free = f"{free_sum / count:.2f}"
                avg_si = f"{si_sum / count:.2f}"
                avg_so = f"{so_sum / count:.2f}"

    # Use a here document-like f-string to write the final formatted report
    report_content = f"""--- Resource Monitoring Report ---

Timestamp: {time.strftime("%Y-%m-%d %H:%M:%S")}
Command Executed: {" ".join(command)}

Average CPU Usage:      {avg_cpu}%
Total System Memory:    {total_memory}
Average Free Memory:    {avg_free} MB
Average Swap Used:      {avg_swpd} MB
Average Swap In:        {avg_si} pages/s
Average Swap Out:       {avg_so} pages/s

--- End of Report ---
"""
    
    with open(REPORT_FILE, 'w') as f:
        f.write(report_content)
    
    print("Report generated and saved to", REPORT_FILE)
    print("--- Test and Monitoring Complete ---")
    print(report_content)


def main():
    if len(sys.argv) < 2:
        print("Error: No command provided.")
        print(f"Usage: {sys.argv[0]} <command_to_run> [arguments...]", file=sys.stderr)
        sys.exit(1)

    command_to_run = sys.argv[1:]
    total_memory = get_total_memory()
    duration = extract_duration_from_command(command_to_run)
    
    # Run the monitoring and user command processes
    try:
        print("--- Executing Command ---")
        user_proc = subprocess.Popen(command_to_run)
        
        mpstat_output, vmstat_output = run_monitoring_commands(duration)
        
        user_proc.wait()
        
    except Exception as e:
        print(f"Error: Failed to execute command. {e}", file=sys.stderr)
        sys.exit(1)
    finally:
        generate_report(command_to_run, mpstat_output, vmstat_output, total_memory)

if __name__ == "__main__":
    main()

